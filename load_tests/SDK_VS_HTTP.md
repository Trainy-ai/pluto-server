# Load Test Approach: SDK vs HTTP

## Current Status

✅ **HTTP-Based Load Test (Working)** - `locustfile_http.py`
✅ **SDK-Based Load Test (Working)** - `locustfile.py`

Both tests are now running in CI!

## Why Run Both Tests?

Both tests provide complementary coverage:

### HTTP Test - Direct Endpoint Testing
- Tests raw HTTP performance without SDK overhead
- Higher throughput (100 users)
- Direct control over request format
- Faster feedback on pure server performance

### SDK Test - Real User Experience
- Tests complete SDK flow including buffering and sync logic
- Validates SDK integration with local services
- Moderate throughput (50 users)
- Catches SDK-specific issues

### How to Configure SDK for Local Services

The SDK can be configured to use local endpoints by setting URL attributes directly:

```python
settings = pluto.Settings()
settings.url_api = "http://server:3001"
settings.url_ingest = "http://ingest:3003"
settings.url_app = "http://server:3001"
settings.url_py = "http://server:3001"
settings._auth = api_key  # Set API key on settings

settings.update({})  # Trigger update_host() and update_url()

# Login with custom settings
pluto.login(settings=settings)

# Initialize run
run = pluto.init(project="...", name="...", settings=settings)
```

## HTTP Load Test: Full Stack Coverage

The HTTP-based test (`locustfile_http.py`) **DOES test the complete stack**:

### What It Tests

1. **Backend API Authentication**
   - Uses the API key generated by our test fixtures
   - Sends `Authorization: Bearer <key>` header
   - Backend validates key against PostgreSQL

2. **Rust Ingest Service**
   - Receives authenticated requests
   - Validates headers (`X-Run-Id`, `X-Project-Name`)
   - Processes NDJSON payloads
   - Buffers with 3-layer system

3. **ClickHouse Writes**
   - Background processors batch records
   - Exponential backoff on failures
   - DLQ persistence on exhaustion

4. **MinIO Storage** (for file uploads)

### Test Results

```
============================================================
LOAD TEST RESULTS
============================================================
Total Requests:  926
Failed Requests: 0
RPS:             31.07
P50 Latency:     2ms
P95 Latency:     3ms (threshold: 500ms)
P99 Latency:     4ms (threshold: 1000ms)
Error Rate:      0.00% (threshold: 1%)
============================================================
✅ All performance thresholds passed!
```

## What the SDK Would Add

The SDK is essentially a convenience wrapper that:
1. Calls the backend API to validate credentials → **We test this via HTTP**
2. Makes HTTP POST requests to `/ingest/metrics`, `/ingest/logs`, `/ingest/data` → **We test this directly**
3. Handles buffering on the client side → **Not relevant for server load testing**

### SDK Code Under the Hood

When you call `run.log(data)`, the SDK essentially does:

```python
# SDK internal implementation (simplified)
def log(self, data):
    ndjson = json.dumps({"time": ..., "step": ..., "data": data}) + "\n"
    requests.post(
        f"{settings.url_ingest}/ingest/metrics",
        data=ndjson,
        headers={
            "Authorization": f"Bearer {api_key}",
            "X-Run-Id": run_id,
            "X-Project-Name": project_name,
        }
    )
```

**This is exactly what our HTTP load test does!**

## Recommendation

Use `locustfile_http.py` for CI/CD load testing because:

1. ✅ Tests the actual server performance bottlenecks
2. ✅ Works in headless environments
3. ✅ Tests full authentication flow
4. ✅ More control over payload format
5. ✅ Easier to debug and maintain
6. ✅ No SDK version dependencies

The SDK test can be added later once we:
- Get SDK updated to support custom URLs before login
- Or find a way to inject settings globally before any SDK initialization

## Running the Tests

### Quick Start (Both Tests)

```bash
# Start infrastructure (includes backend server!)
docker compose -f .buildkite/docker-compose.loadtest.yml up -d --wait

# Generate test fixtures
docker compose -f .buildkite/docker-compose.loadtest.yml run --rm setup

# Build test image
docker build -t pluto-loadtest:latest ./load_tests

# Run HTTP test
docker run --rm --network buildkite_default \
  -v "$PWD/load_tests/reports:/mnt/locust/reports" \
  -e INGEST_URL=http://ingest:3003 \
  -e TEST_API_KEY=mlps_loadtest_deterministic_key_for_ci_load_tests_12345678 \
  pluto-loadtest:latest \
  -f /mnt/locust/locustfile_http.py \
  --headless \
  --users 10 \
  --spawn-rate 2 \
  --run-time 30s \
  --html /mnt/locust/reports/report_http.html

# Run SDK test
docker run --rm --network buildkite_default \
  -v "$PWD/load_tests/reports:/mnt/locust/reports" \
  -e INGEST_URL=http://ingest:3003 \
  -e TEST_API_KEY=mlps_loadtest_deterministic_key_for_ci_load_tests_12345678 \
  pluto-loadtest:latest \
  -f /mnt/locust/locustfile.py \
  --headless \
  --users 5 \
  --spawn-rate 1 \
  --run-time 30s \
  --html /mnt/locust/reports/report_sdk.html
```

### Services Running in Load Test

- PostgreSQL (port 5432) - Metadata storage
- ClickHouse (port 8123) - Time-series data
- MinIO (port 9000) - S3-compatible storage
- **Backend Server (port 3001)** - Next.js API (authenticates API keys)
- Rust Ingest (port 3003) - High-performance ingestion

## Test Results Comparison

### HTTP Test
```
Total Requests:  926
RPS:             31.07
P50 Latency:     2ms
P95 Latency:     3ms
P99 Latency:     4ms
Error Rate:      0.00%
```

### SDK Test
```
Total Requests:  472
RPS:             15.77
P50 Latency:     0ms
P95 Latency:     0ms
P99 Latency:     1ms
Error Rate:      0.00%
```

**Why different performance?**
- HTTP test: Direct HTTP requests with minimal overhead
- SDK test: Includes SDK buffering, sync logic, and additional API calls for status updates

Both tests pass all thresholds (p95 < 500ms, p99 < 1000ms, errors < 1%)
